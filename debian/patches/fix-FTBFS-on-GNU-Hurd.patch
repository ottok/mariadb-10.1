From: Debian MySQL Maintainers <pkg-mysql-maint@lists.alioth.debian.org>
Date: Thu, 10 Aug 2017 20:40:29 +0200
Subject: fix-FTBFS-on-GNU-Hurd

---
 cmake/dtrace.cmake                            |  4 +++
 cmake/package_name.cmake                      |  3 ++
 extra/mariabackup/backup_copy.cc              | 29 +++++++++++++-----
 mysys/mysys_priv.h                            | 10 +++++--
 sql/wsrep_binlog.cc                           | 42 ++++++++++++++++++++-------
 storage/mroonga/vendor/groonga/config.h.cmake |  1 +
 storage/mroonga/vendor/groonga/lib/com.c      | 10 +++----
 storage/mroonga/vendor/groonga/lib/grn_com.h  | 24 ++++++++-------
 8 files changed, 86 insertions(+), 37 deletions(-)

--- a/cmake/dtrace.cmake
+++ b/cmake/dtrace.cmake
@@ -45,6 +45,10 @@ MACRO(CHECK_DTRACE)
      AND NOT BUGGY_LINUX_DTRACE) 
    SET(ENABLE_DTRACE ON CACHE BOOL "Enable dtrace")
  ENDIF()
+ # On GNU/Hurd, dtrace is not supported
+ IF(DTRACE AND CMAKE_SYSTEM_NAME MATCHES "GNU")
+   SET(ENABLE_DTRACE OFF CACHE BOOL "Disable dtrace")
+ ENDIF()
  SET(HAVE_DTRACE ${ENABLE_DTRACE})
  IF(CMAKE_SYSTEM_NAME MATCHES "SunOS")
    IF(CMAKE_SIZEOF_VOID_P EQUAL 4)
--- a/cmake/package_name.cmake
+++ b/cmake/package_name.cmake
@@ -81,6 +81,9 @@ IF(NOT VERSION)
           SET(DEFAULT_MACHINE "i386")
         ENDIF()
       ENDIF()
+    ELSEIF(CMAKE_SYSTEM_NAME MATCHES "GNU")
+      SET(DEFAULT_PLATFORM "GNU")
+      SET(DEFAULT_MACHINE "i386")
     ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Darwin")
       IF(CMAKE_OSX_DEPLOYMENT_TARGET)
         SET(DEFAULT_PLATFORM "osx${CMAKE_OSX_DEPLOYMENT_TARGET}")
--- a/extra/mariabackup/backup_copy.cc
+++ b/extra/mariabackup/backup_copy.cc
@@ -623,11 +623,13 @@ static
 int
 mkdirp(const char *pathname, int Flags, myf MyFlags)
 {
-	char parent[PATH_MAX], *p;
+	char *parent, *p;
+	int len = strlen(pathname) + 1;
 
 	/* make a parent directory path */
-	strncpy(parent, pathname, sizeof(parent));
-	parent[sizeof(parent) - 1] = 0;
+	parent = (char *)malloc(len);
+	strncpy(parent, pathname, len);
+	parent[len] = 0;
 
 	for (p = parent + strlen(parent);
 	    !is_path_separator(*p) && p != parent; p--);
@@ -636,19 +638,23 @@ mkdirp(const char *pathname, int Flags,
 
 	/* try to make parent directory */
 	if (p != parent && mkdirp(parent, Flags, MyFlags) != 0) {
+		free(parent);
 		return(-1);
 	}
 
 	/* make this one if parent has been made */
 	if (my_mkdir(pathname, Flags, MyFlags) == 0) {
+		free(parent);
 		return(0);
 	}
 
 	/* if it already exists that is fine */
 	if (errno == EEXIST) {
+		free(parent);
 		return(0);
 	}
 
+	free(parent);
 	return(-1);
 }
 
@@ -658,17 +664,24 @@ bool
 equal_paths(const char *first, const char *second)
 {
 #ifdef HAVE_REALPATH
-	char real_first[PATH_MAX];
-	char real_second[PATH_MAX];
+	char *real_first, *real_second;
+	int result;
 
-	if (realpath(first, real_first) == NULL) {
+	real_first = realpath(first, 0);
+	if (real_first == NULL) {
 		return false;
 	}
-	if (realpath(second, real_second) == NULL) {
+
+	real_second = realpath(second, 0);
+	if (real_second == NULL) {
+		free(real_second);
 		return false;
 	}
 
-	return (strcmp(real_first, real_second) == 0);
+	result = strcmp(real_first, real_second);
+	free(real_first);
+	free(real_second);
+	return result == 0;
 #else
 	return strcmp(first, second) == 0;
 #endif
--- a/mysys/mysys_priv.h
+++ b/mysys/mysys_priv.h
@@ -16,6 +16,10 @@
 #ifndef MYSYS_PRIV_INCLUDED
 #define MYSYS_PRIV_INCLUDED
 
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
 #include <my_global.h>
 #include <my_sys.h>
 #include <my_crypt.h>
@@ -111,7 +115,7 @@ void my_error_unregister_all(void);
 #ifndef O_PATH        /* not Linux */
 #if defined(O_SEARCH) /* Illumos */
 #define O_PATH O_SEARCH
-#elif defined(O_EXEC) /* FreeBSD */
+#elif defined(O_EXEC) && defined(__FreeBSD_kernel__) /* FreeBSD */
 #define O_PATH O_EXEC
 #endif
 #endif
@@ -128,8 +132,8 @@ const char *my_open_parent_dir_nosymlink
   return res;
 #elif defined(HAVE_REALPATH) && defined(PATH_MAX)
 #define NOSYMLINK_FUNCTION_BODY(AT,NOAT)                                \
-  char buf[PATH_MAX+1];                                                 \
-  if (realpath(pathname, buf) == NULL) return -1;                       \
+  char *buf = realpath(NULL, 0);                                        \
+  if (buf == NULL) return -1;                                           \
   if (strcmp(pathname, buf)) { errno= ENOTDIR; return -1; }             \
   return NOAT;
 #elif defined(HAVE_REALPATH)
--- a/sql/wsrep_binlog.cc
+++ b/sql/wsrep_binlog.cc
@@ -318,13 +318,23 @@ int wsrep_write_cache(wsrep_t*  const ws
 
 void wsrep_dump_rbr_buf(THD *thd, const void* rbr_buf, size_t buf_len)
 {
-  char filename[PATH_MAX]= {0};
-  int len= snprintf(filename, PATH_MAX, "%s/GRA_%ld_%lld.log",
+  int len = snprintf(NULL, 0, "%s/GRA_%ld_%lld.log",
                     wsrep_data_home_dir, thd->thread_id,
                     (long long)wsrep_thd_trx_seqno(thd));
-  if (len >= PATH_MAX)
+  if (len < 0)
   {
-    WSREP_ERROR("RBR dump path too long: %d, skipping dump.", len);
+    WSREP_ERROR("snprintf error: %d, skipping dump.", len);
+    DBUG_VOID_RETURN;
+  }
+
+  char *filename= (char *)malloc(len++);
+  int len1= snprintf(filename, len, "%s/GRA_%ld_%lld.log",
+                    wsrep_data_home_dir, thd->thread_id,
+                    (long long)wsrep_thd_trx_seqno(thd));
+  if (len >= len1)
+  {
+    WSREP_ERROR("RBR dump path truncated: %d, skipping dump.", len);
+    free(filename);
     return;
   }
 
@@ -343,6 +353,7 @@ void wsrep_dump_rbr_buf(THD *thd, const
     WSREP_ERROR("Failed to open file '%s': %d (%s)",
                 filename, errno, strerror(errno));
   }
+  free(filename);
 }
 
 /*
@@ -448,19 +459,29 @@ void wsrep_dump_rbr_buf_with_header(THD
 {
   DBUG_ENTER("wsrep_dump_rbr_buf_with_header");
 
-  char filename[PATH_MAX]= {0};
   File file;
   IO_CACHE cache;
   Log_event_writer writer(&cache);
   Format_description_log_event *ev=NULL;
 
-  int len= my_snprintf(filename, PATH_MAX, "%s/GRA_%ld_%lld_v2.log",
-                       wsrep_data_home_dir, thd->thread_id,
-                       (long long) wsrep_thd_trx_seqno(thd));
+  int len = snprintf(NULL, 0, "%s/GRA_%ld_%lld_v2.log",
+		     wsrep_data_home_dir, thd->thread_id,
+		     (long long) wsrep_thd_trx_seqno(thd));
 
-  if (len >= PATH_MAX)
+  if (len < 0)
   {
-    WSREP_ERROR("RBR dump path too long: %d, skipping dump.", len);
+    WSREP_ERROR("snprintf error: %d, skipping dump.", len);
+    DBUG_VOID_RETURN;
+  }
+
+  char *filename = (char *)malloc(len++);
+  int len1 = my_snprintf(filename, len, "%s/GRA_%ld_%lld_v2.log",
+			 wsrep_data_home_dir, thd->thread_id,
+			 (long long) wsrep_thd_trx_seqno(thd));
+  
+  if (len >= len1)
+  {
+    WSREP_ERROR("RBR dump path truncated: %d, skipping dump.", len);
     DBUG_VOID_RETURN;
   }
 
@@ -498,6 +519,7 @@ void wsrep_dump_rbr_buf_with_header(THD
   }
 
 cleanup2:
+  free(filename);
   end_io_cache(&cache);
 
 cleanup1:
--- a/storage/mroonga/vendor/groonga/config.h.cmake
+++ b/storage/mroonga/vendor/groonga/config.h.cmake
@@ -107,6 +107,7 @@
 #cmakedefine HAVE_SIGNAL_H
 #cmakedefine HAVE_SYS_MMAN_H
 #cmakedefine HAVE_SYS_PARAM_H
+#cmakedefine HAVE_SYS_POLL_H
 #cmakedefine HAVE_SYS_RESOURCE_H
 #cmakedefine HAVE_SYS_SELECT_H
 #cmakedefine HAVE_SYS_SOCKET_H
--- a/storage/mroonga/vendor/groonga/lib/com.c
+++ b/storage/mroonga/vendor/groonga/lib/com.c
@@ -281,7 +281,7 @@ grn_com_event_init(grn_ctx *ctx, grn_com
     memset(&(ev->curr_edge_id), 0, sizeof(grn_com_addr));
     ev->acceptor = NULL;
     ev->opaque = NULL;
-#ifndef USE_SELECT
+#if !defined(USE_SELECT) && !defined(USE_POLL)
 # ifdef USE_EPOLL
     if ((ev->events = GRN_MALLOC(sizeof(struct epoll_event) * max_nevents))) {
       if ((ev->epfd = epoll_create(max_nevents)) != -1) {
@@ -310,9 +310,9 @@ grn_com_event_init(grn_ctx *ctx, grn_com
     grn_hash_close(ctx, ev->hash);
     ev->hash = NULL;
     ev->events = NULL;
-#else /* USE_SELECT */
+#else /* USE_SELECT && USE_POLL */
     goto exit;
-#endif /* USE_SELECT */
+#endif /* USE_SELECT && USE_POLL */
   }
 exit :
   return ctx->rc;
@@ -326,7 +326,7 @@ grn_com_event_fin(grn_ctx *ctx, grn_com_
     grn_msg_close(ctx, msg);
   }
   if (ev->hash) { grn_hash_close(ctx, ev->hash); }
-#ifndef USE_SELECT
+#if !defined(USE_SELECT) && !defined(USE_POLL)
   if (ev->events) { GRN_FREE(ev->events); }
 # ifdef USE_EPOLL
   grn_close(ev->epfd);
@@ -334,7 +334,7 @@ grn_com_event_fin(grn_ctx *ctx, grn_com_
 # ifdef USE_KQUEUE
   grn_close(ev->kqfd);
 # endif /* USE_KQUEUE*/
-#endif /* USE_SELECT */
+#endif /* USE_SELECT && USE_POLL */
   return GRN_SUCCESS;
 }
 
--- a/storage/mroonga/vendor/groonga/lib/grn_com.h
+++ b/storage/mroonga/vendor/groonga/lib/grn_com.h
@@ -66,13 +66,22 @@ GRN_API grn_com_queue_entry *grn_com_que
 
 /******* grn_com ********/
 
-#ifdef USE_SELECT
+#if defined(USE_SELECT)
 # ifdef HAVE_SYS_SELECT_H
 #  include <sys/select.h>
 # endif /* HAVE_SYS_SELECT_H */
 # define GRN_COM_POLLIN  1
 # define GRN_COM_POLLOUT 2
 #else /* USE_SELECT */
+# ifdef USE_POLL
+#  if defined(HAVE_POLL_H)
+#    include <poll.h>
+#  elif defined(HAVE_SYS_POLL_H)
+#    include <sys/poll.h>
+#  endif /* defined(HAVE_POLL_H) */
+#  define GRN_COM_POLLIN  POLLIN
+#  define GRN_COM_POLLOUT POLLOUT
+#else /* USE_POLL */
 # ifdef USE_EPOLL
 #  include <sys/epoll.h>
 #  define GRN_COM_POLLIN  EPOLLIN
@@ -82,12 +91,9 @@ GRN_API grn_com_queue_entry *grn_com_que
 #   include <sys/event.h>
 #   define GRN_COM_POLLIN  EVFILT_READ
 #   define GRN_COM_POLLOUT EVFILT_WRITE
-#  else /* USE_KQUEUE */
-#   include <poll.h>
-#   define GRN_COM_POLLIN  POLLIN
-#   define GRN_COM_POLLOUT POLLOUT
 #  endif /* USE_KQUEUE */
 # endif /* USE_EPOLL */
+#endif /* USE_POLL */
 #endif /* USE_SELECT */
 
 typedef struct _grn_com grn_com;
@@ -133,7 +139,7 @@ struct _grn_com_event {
   grn_com_addr curr_edge_id;
   grn_com *acceptor;
   void *opaque;
-#ifndef USE_SELECT
+#if !defined(USE_SELECT) || !defined(USE_POLL)
 #ifdef USE_EPOLL
   int epfd;
   struct epoll_event *events;
@@ -146,7 +152,7 @@ struct _grn_com_event {
   struct pollfd *events;
 #endif /* USE_KQUEUE */
 #endif /* USE_EPOLL */
-#endif /* USE_SELECT */
+#endif /* USE_SELECT || USE_POLL */
 };
 
 grn_rc grn_com_init(void);
